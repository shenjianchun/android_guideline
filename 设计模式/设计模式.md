

# 设计模式

## 一、设计原则

### S.O.L.I.D

| 简写 | 全拼                                | 中文翻译     |
| ---- | ----------------------------------- | ------------ |
| SRP  | The Single Responsibility Principle | 单一责任原则 |
| OCP  | The Open Closed Principle           | 开放封闭原则 |
| LSP  | The Liskov Substitution Principle   | 里氏替换原则 |
| ISP  | The Interface Segregation Principle | 接口分离原则 |
| DIP  | The Dependency Inversion Principle  | 依赖倒置原则 |

#### 1. 单一责任原则

> 修改一个类的原因应该只有一个。

换句话说就是让一个类只负责一件事，当这个类需要做过多事情的时候，就需要分解这个类。

如果一个类承担的职责过多，就等于把这些职责耦合在了一起，一个职责的变化可能会削弱这个类完成其它职责的能力。

#### 2. 开放封闭原则

> 类应该对扩展开放，对修改关闭。

扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。

符合开闭原则最典型的设计模式是装饰者模式，它可以动态地将责任附加到对象上，而不用去修改类的代码。

#### 3. 里氏替换原则

> 子类对象必须能够替换掉所有父类对象。

继承是一种 IS-A 关系，子类需要能够当成父类来使用，并且需要比父类更特殊。

如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。

#### 4. 接口分离原则

> 不应该强迫客户依赖于它们不用的方法。

因此使用多个专门的接口比使用单一的总接口要好。

#### 5. 依赖倒置原则

> 高层模块不应该依赖于低层模块，二者都应该依赖于抽象；
> 抽象不应该依赖于细节，细节应该依赖于抽象。

高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于低层模块，那么低层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。

依赖于抽象意味着：

- 任何变量都不应该持有一个指向具体类的指针或者引用；
- 任何类都不应该从具体类派生；
- 任何方法都不应该覆写它的任何基类中的已经实现的方法。



#### 总结

**几个原则最终就可以化为这几个关键字：抽象、单一职责、最小化**



## 二、面向对象的思想



> 封装、继承、多态



### 封装

利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体。数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外的接口使其与外部发生联系。用户无需关心对象内部的细节，但可以通过对象对外提供的接口来访问该对象。

优点：

- 减少耦合：可以独立地开发、测试、优化、使用、理解和修改
- 减轻维护的负担：可以更容易被理解，并且在调试的时候可以不影响其他模块
- 有效地调节性能：可以通过剖析来确定哪些模块影响了系统的性能
- 提高软件的可重用性
- 降低了构建大型系统的风险：即使整个系统不可用，但是这些独立的模块却有可能是可用的

以下 Person 类封装 name、gender、age 等属性，外界只能通过 get() 方法获取一个 Person 对象的 name 属性和 gender 属性，而无法获取 age 属性，但是 age 属性可以供 work() 方法使用。

注意到 gender 属性使用 int 数据类型进行存储，封装使得用户注意不到这种实现细节。并且在需要修改 gender 属性使用的数据类型时，也可以在不影响客户端代码的情况下进行。

```
public class Person {

    private String name;
    private int gender;
    private int age;

    public String getName() {
        return name;
    }

    public String getGender() {
        return gender == 0 ? "man" : "woman";
    }

    public void work() {
        if (18 <= age && age <= 50) {
            System.out.println(name + " is working very hard!");
        } else {
            System.out.println(name + " can't work any more!");
        }
    }
}
```

### 继承

继承实现了 **IS-A** 关系，例如 Cat 和 Animal 就是一种 IS-A 关系，因此 Cat 可以继承自 Animal，从而获得 Animal 非 private 的属性和方法。

继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。

Cat 可以当做 Animal 来使用，也就是说可以使用 Animal 引用 Cat 对象。父类引用指向子类对象称为 **向上转型** 。

```
Animal animal = new Cat();
```



### 多态

多态分为编译时多态和运行时多态：

- 编译时多态主要指方法的重载
- 运行时多态指程序中定义的对象引用所指向的具体类型在运行期间才确定

运行时多态有三个条件：

- 继承
- 覆盖（重写）
- 向上转型

下面的代码中，乐器类（Instrument）有两个子类：Wind 和 Percussion，它们都覆盖了父类的 play() 方法，并且在 main() 方法中使用父类 Instrument 来引用 Wind 和 Percussion 对象。在 Instrument 引用调用 play() 方法时，会执行实际引用对象所在类的 play() 方法，而不是 Instrument 类的方法。

```java
public class Instrument {

    public void play() {
        System.out.println("Instument is playing...");
    }
}
public class Wind extends Instrument {

    public void play() {
        System.out.println("Wind is playing...");
    }
}
public class Percussion extends Instrument {

    public void play() {
        System.out.println("Percussion is playing...");
    }
}
public class Music {

    public static void main(String[] args) {
        List<Instrument> instruments = new ArrayList<>();
        instruments.add(new Wind());
        instruments.add(new Percussion());
        for(Instrument instrument : instruments) {
            instrument.play();
        }
    }
}

Wind is playing...
Percussion is playing...
```



## 三、设计模式

创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式

结构型模式，共七种：适配器模式、装饰者模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。


### 创建型模式

- **单例模式**

  ### Intent

  确保一个类只有一个实例，并提供该实例的全局访问点。

  ### Class Diagram

  使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现。

  私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量。

  ![img](https://camo.githubusercontent.com/d6b249ab6469504ada64c4558719b7cb7ebdf9e9faa177d5ce98d66b75ce7319/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65636131663432322d383338312d343039622d616430342d3938656633396165333862612e706e67)

  

  ### Implementation

  #### Ⅰ 懒汉式-线程不安全

  以下实现中，私有静态变量 uniqueInstance 被延迟实例化，这样做的好处是，如果没有用到该类，那么就不会实例化 uniqueInstance，从而节约资源。

  这个实现在多线程环境下是不安全的，如果多个线程能够同时进入 `if (uniqueInstance == null)` ，并且此时 uniqueInstance 为 null，那么会有多个线程执行 `uniqueInstance = new Singleton();` 语句，这将导致实例化多次 uniqueInstance。

  ```
  public class Singleton {
  
      private static Singleton uniqueInstance;
  
      private Singleton() {
      }
  
      public static Singleton getUniqueInstance() {
          if (uniqueInstance == null) {
              uniqueInstance = new Singleton();
          }
          return uniqueInstance;
      }
  }
  ```

  #### Ⅱ 饿汉式-线程安全

  线程不安全问题主要是由于 uniqueInstance 被实例化多次，采取直接实例化 uniqueInstance 的方式就不会产生线程不安全问题。

  但是直接实例化的方式也丢失了延迟实例化带来的节约资源的好处。

  ```
  private static Singleton uniqueInstance = new Singleton();
  ```

  #### Ⅲ 懒汉式-线程安全

  只需要对 getUniqueInstance() 方法加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了实例化多次 uniqueInstance。

  但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 uniqueInstance 已经被实例化了。这会让线程阻塞时间过长，因此该方法有性能问题，不推荐使用。

  ```
  public static synchronized Singleton getUniqueInstance() {
      if (uniqueInstance == null) {
          uniqueInstance = new Singleton();
      }
      return uniqueInstance;
  }
  ```

  #### Ⅳ 双重校验锁-线程安全

  uniqueInstance 只需要被实例化一次，之后就可以直接使用了。加锁操作只需要对实例化那部分的代码进行，只有当 uniqueInstance 没有被实例化时，才需要进行加锁。

  双重校验锁先判断 uniqueInstance 是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。

  ```
  public class Singleton {
  
      private volatile static Singleton uniqueInstance;
  
      private Singleton() {
      }
  
      public static Singleton getUniqueInstance() {
          if (uniqueInstance == null) {
              synchronized (Singleton.class) {
                  if (uniqueInstance == null) {
                      uniqueInstance = new Singleton();
                  }
              }
          }
          return uniqueInstance;
      }
  }
  ```

  考虑下面的实现，也就是只使用了一个 if 语句。在 uniqueInstance == null 的情况下，如果两个线程都执行了 if 语句，那么两个线程都会进入 if 语句块内。虽然在 if 语句块内有加锁操作，但是两个线程都会执行 `uniqueInstance = new Singleton();` 这条语句，只是先后的问题，那么就会进行两次实例化。因此必须使用双重校验锁，也就是需要使用两个 if 语句：第一个 if 语句用来避免 uniqueInstance 已经被实例化之后的加锁操作，而第二个 if 语句进行了加锁，所以只能有一个线程进入，就不会出现 uniqueInstance == null 时两个线程同时进行实例化操作。

  ```
  if (uniqueInstance == null) {
      synchronized (Singleton.class) {
          uniqueInstance = new Singleton();
      }
  }
  ```

  uniqueInstance 采用 volatile 关键字修饰也是很有必要的， `uniqueInstance = new Singleton();` 这段代码其实是分为三步执行：

  1. 为 uniqueInstance 分配内存空间
  2. 初始化 uniqueInstance
  3. 将 uniqueInstance 指向分配的内存地址

  但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1>3>2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。

  使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。

  #### Ⅴ 静态内部类实现

  当 Singleton 类被加载时，静态内部类 SingletonHolder 没有被加载进内存。只有当调用 `getUniqueInstance()` 方法从而触发 `SingletonHolder.INSTANCE` 时 SingletonHolder 才会被加载，此时初始化 INSTANCE 实例，并且 JVM 能确保 INSTANCE 只被实例化一次。

  这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。

  ```
  public class Singleton {
  
      private Singleton() {
      }
  
      private static class SingletonHolder {
          private static final Singleton INSTANCE = new Singleton();
      }
  
      public static Singleton getUniqueInstance() {
          return SingletonHolder.INSTANCE;
      }
  }
  ```

  #### Ⅵ 枚举实现

  ```
  public enum Singleton {
  
      INSTANCE;
  
      private String objName;
  
  
      public String getObjName() {
          return objName;
      }
  
  
      public void setObjName(String objName) {
          this.objName = objName;
      }
  
  
      public static void main(String[] args) {
  
          // 单例测试
          Singleton firstSingleton = Singleton.INSTANCE;
          firstSingleton.setObjName("firstName");
          System.out.println(firstSingleton.getObjName());
          Singleton secondSingleton = Singleton.INSTANCE;
          secondSingleton.setObjName("secondName");
          System.out.println(firstSingleton.getObjName());
          System.out.println(secondSingleton.getObjName());
  
          // 反射获取实例测试
          try {
              Singleton[] enumConstants = Singleton.class.getEnumConstants();
              for (Singleton enumConstant : enumConstants) {
                  System.out.println(enumConstant.getObjName());
              }
          } catch (Exception e) {
              e.printStackTrace();
          }
      }
  }
  firstName
  secondName
  secondName
  secondName
  ```

  该实现可以防止反射攻击。在其它实现中，通过 setAccessible() 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。

  该实现在多次序列化和序列化之后，不会得到多个实例。而其它实现需要使用 transient 修饰所有字段，并且实现序列化和反序列化的方法。

  

  #### Android

  * Android源码中的单例模式（Android的 getSystemSevice）

  

- **简单工厂模式**

  ### Intent

  在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。

  ### Class Diagram

  简单工厂把实例化的操作单独放到一个类中，这个类就成为简单工厂类，让简单工厂类来决定应该用哪个具体子类来实例化。

  这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。

  [![img](https://camo.githubusercontent.com/4b9c4f81a0887cb9161a3b744e448ce6cc0bb324c65150726726041c802d9f51/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34306330633137652d626261362d343439332d393835372d3134376330303434613031382e706e67)](https://camo.githubusercontent.com/4b9c4f81a0887cb9161a3b744e448ce6cc0bb324c65150726726041c802d9f51/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f34306330633137652d626261362d343439332d393835372d3134376330303434613031382e706e67)

  

  ### Implementation

  ```java
  public interface Product {
  }
  public class ConcreteProduct implements Product {
  }
  public class ConcreteProduct1 implements Product {
  }
  public class ConcreteProduct2 implements Product {
  }
  ```

  以下的 Client 类包含了实例化的代码，这是一种错误的实现。如果在客户类中存在这种实例化代码，就需要考虑将代码放到简单工厂中。

  ```java
  public class Client {
  
      public static void main(String[] args) {
          int type = 1;
          Product product;
          if (type == 1) {
              product = new ConcreteProduct1();
          } else if (type == 2) {
              product = new ConcreteProduct2();
          } else {
              product = new ConcreteProduct();
          }
          // do something with the product
      }
  }
  ```

  以下的 SimpleFactory 是简单工厂实现，它被所有需要进行实例化的客户类调用。

  ```java
  public class SimpleFactory {
  
      public Product createProduct(int type) {
          if (type == 1) {
              return new ConcreteProduct1();
          } else if (type == 2) {
              return new ConcreteProduct2();
          }
          return new ConcreteProduct();
      }
  }
  public class Client {
  
      public static void main(String[] args) {
          SimpleFactory simpleFactory = new SimpleFactory();
          Product product = simpleFactory.createProduct(1);
          // do something with the product
      }
  }
  ```

  

- **工厂方法模式**

  ### Intent

  定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。

  ### Class Diagram

  在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。

  下图中，Factory 有一个 doSomething() 方法，这个方法需要用到一个产品对象，这个产品对象由 factoryMethod() 方法创建。该方法是抽象的，需要由子类去实现。

  [![img](https://camo.githubusercontent.com/ee2134c1575c4a1924a762b1ac4fdbe9f3536515b25682ca1d10b3ea1ee371bb/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66346430616664302d386537382d343931342d396536302d3433363665616630363562352e706e67)](https://camo.githubusercontent.com/ee2134c1575c4a1924a762b1ac4fdbe9f3536515b25682ca1d10b3ea1ee371bb/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66346430616664302d386537382d343931342d396536302d3433363665616630363562352e706e67)

  

  ### Implementation

  ```
  public abstract class Factory {
      public abstract Product factoryMethod();
      public void doSomething() {
          Product product = factoryMethod();
          // do something with the product
      }
  }
  public class ConcreteFactory extends Factory {
      public Product factoryMethod() {
          return new ConcreteProduct();
      }
  }
  public class ConcreteFactory1 extends Factory {
      public Product factoryMethod() {
          return new ConcreteProduct1();
      }
  }
  public class ConcreteFactory2 extends Factory {
      public Product factoryMethod() {
          return new ConcreteProduct2();
      }
  }
  ```

  ### JDK

  - [java.util.Calendar](http://docs.oracle.com/javase/8/docs/api/java/util/Calendar.html#getInstance--)
  - [java.util.ResourceBundle](http://docs.oracle.com/javase/8/docs/api/java/util/ResourceBundle.html#getBundle-java.lang.String-)
  - [java.text.NumberFormat](http://docs.oracle.com/javase/8/docs/api/java/text/NumberFormat.html#getInstance--)
  - [java.nio.charset.Charset](http://docs.oracle.com/javase/8/docs/api/java/nio/charset/Charset.html#forName-java.lang.String-)
  - [java.net.URLStreamHandlerFactory](http://docs.oracle.com/javase/8/docs/api/java/net/URLStreamHandlerFactory.html#createURLStreamHandler-java.lang.String-)
  - [java.util.EnumSet](https://docs.oracle.com/javase/8/docs/api/java/util/EnumSet.html#of-E-)
  - [javax.xml.bind.JAXBContext](https://docs.oracle.com/javase/8/docs/api/javax/xml/bind/JAXBContext.html#createMarshaller--)

  #### Android

  * ArrayList和HashSet的iterator方法，Android Activity 中onCreate方法

  

- **抽象工厂模式**

  ### Intent

  提供一个接口，用于创建 **相关的对象家族** 。

  ### Class Diagram

  抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。

  抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory 中的 createProductA() 和 createProductB() 方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。

  至于创建对象的家族这一概念是在 Client 体现，Client 要通过 AbstractFactory 同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client 需要同时创建出这两个对象。

  从高层次来看，抽象工厂使用了组合，即 Cilent 组合了 AbstractFactory，而工厂方法模式使用了继承。

  [![img](https://camo.githubusercontent.com/52e67b2cd79f9b1a005b207b88eb841772458242b515a4242b61dfcd88142c48/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65323139306333362d386232372d343639302d626465352d3939313130323061313239342e706e67)](https://camo.githubusercontent.com/52e67b2cd79f9b1a005b207b88eb841772458242b515a4242b61dfcd88142c48/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65323139306333362d386232372d343639302d626465352d3939313130323061313239342e706e67)

  

  ### Implementation

  ```
  public class AbstractProductA {
  }
  public class AbstractProductB {
  }
  public class ProductA1 extends AbstractProductA {
  }
  public class ProductA2 extends AbstractProductA {
  }
  public class ProductB1 extends AbstractProductB {
  }
  public class ProductB2 extends AbstractProductB {
  }
  public abstract class AbstractFactory {
      abstract AbstractProductA createProductA();
      abstract AbstractProductB createProductB();
  }
  public class ConcreteFactory1 extends AbstractFactory {
      AbstractProductA createProductA() {
          return new ProductA1();
      }
  
      AbstractProductB createProductB() {
          return new ProductB1();
      }
  }
  public class ConcreteFactory2 extends AbstractFactory {
      AbstractProductA createProductA() {
          return new ProductA2();
      }
  
      AbstractProductB createProductB() {
          return new ProductB2();
      }
  }
  public class Client {
      public static void main(String[] args) {
          AbstractFactory abstractFactory = new ConcreteFactory1();
          AbstractProductA productA = abstractFactory.createProductA();
          AbstractProductB productB = abstractFactory.createProductB();
          // do something with productA and productB
      }
  }
  ```

  ### JDK

  - [javax.xml.parsers.DocumentBuilderFactory](http://docs.oracle.com/javase/8/docs/api/javax/xml/parsers/DocumentBuilderFactory.html)
  - [javax.xml.transform.TransformerFactory](http://docs.oracle.com/javase/8/docs/api/javax/xml/transform/TransformerFactory.html#newInstance--)
  - [javax.xml.xpath.XPathFactory](http://docs.oracle.com/javase/8/docs/api/javax/xml/xpath/XPathFactory.html#newInstance--)

  #### Android

  * Android底层对MediaPlayer的实现

  

- Builder模式

  ### Intent

  封装一个对象的构造过程，并允许按步骤构造。

  ### Class Diagram

  [![img](https://camo.githubusercontent.com/a14b3fa54146d168e213302d6352d5874346b2fc79e343bee3dc841e97f30992/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f64623565333736642d306233652d343930652d613433612d3332333139313462363636382e706e67)](https://camo.githubusercontent.com/a14b3fa54146d168e213302d6352d5874346b2fc79e343bee3dc841e97f30992/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f64623565333736642d306233652d343930652d613433612d3332333139313462363636382e706e67)

  

  ### Implementation

  以下是一个简易的 StringBuilder 实现，参考了 JDK 1.8 源码。

  ```
  public class AbstractStringBuilder {
      protected char[] value;
  
      protected int count;
  
      public AbstractStringBuilder(int capacity) {
          count = 0;
          value = new char[capacity];
      }
  
      public AbstractStringBuilder append(char c) {
          ensureCapacityInternal(count + 1);
          value[count++] = c;
          return this;
      }
  
      private void ensureCapacityInternal(int minimumCapacity) {
          // overflow-conscious code
          if (minimumCapacity - value.length > 0)
              expandCapacity(minimumCapacity);
      }
  
      void expandCapacity(int minimumCapacity) {
          int newCapacity = value.length * 2 + 2;
          if (newCapacity - minimumCapacity < 0)
              newCapacity = minimumCapacity;
          if (newCapacity < 0) {
              if (minimumCapacity < 0) // overflow
                  throw new OutOfMemoryError();
              newCapacity = Integer.MAX_VALUE;
          }
          value = Arrays.copyOf(value, newCapacity);
      }
  }
  public class StringBuilder extends AbstractStringBuilder {
      public StringBuilder() {
          super(16);
      }
  
      @Override
      public String toString() {
          // Create a copy, don't share the array
          return new String(value, 0, count);
      }
  }
  public class Client {
      public static void main(String[] args) {
          StringBuilder sb = new StringBuilder();
          final int count = 26;
          for (int i = 0; i < count; i++) {
              sb.append((char) ('a' + i));
          }
          System.out.println(sb.toString());
      }
  }
  abcdefghijklmnopqrstuvwxyz
  ```

  ### JDK

  - [java.lang.StringBuilder](http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html)
  - [java.nio.ByteBuffer](http://docs.oracle.com/javase/8/docs/api/java/nio/ByteBuffer.html#put-byte-)
  - [java.lang.StringBuffer](http://docs.oracle.com/javase/8/docs/api/java/lang/StringBuffer.html#append-boolean-)
  - [java.lang.Appendable](http://docs.oracle.com/javase/8/docs/api/java/lang/Appendable.html)
  - [Apache Camel builders](https://github.com/apache/camel/tree/0e195428ee04531be27a0b659005e3aa8d159d23/camel-core/src/main/java/org/apache/camel/builder)
  - Android源码中的Builder模式实现（AlertDialog）

  

- **原型模式**

  ### Intent

  使用原型实例指定要创建对象的类型，通过复制这个原型来创建新对象。

  ### Class Diagram

  [![img](https://camo.githubusercontent.com/257e892ab993b7d4b1055b6c721df4a080b63b357014707466d3c245360bcbc5/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62383932326638632d393565362d343138372d626538352d3537326135303961666237312e706e67)](https://camo.githubusercontent.com/257e892ab993b7d4b1055b6c721df4a080b63b357014707466d3c245360bcbc5/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62383932326638632d393565362d343138372d626538352d3537326135303961666237312e706e67)

  

  ### Implementation

  ```java
  public abstract class Prototype {
      abstract Prototype myClone();
  }
  public class ConcretePrototype extends Prototype {
  
      private String filed;
  
      public ConcretePrototype(String filed) {
          this.filed = filed;
      }
  
      @Override
      Prototype myClone() {
          return new ConcretePrototype(filed);
      }
  
      @Override
      public String toString() {
          return filed;
      }
  }
  public class Client {
      public static void main(String[] args) {
          Prototype prototype = new ConcretePrototype("abc");
          Prototype clone = prototype.myClone();
          System.out.println(clone.toString());
      }
  }
  abc
  ```

  

  #### Android源码

  * Intent clone函数



### 结构型模式

- **适配器Adapter**

  ### Intent

  把一个类接口转换成另一个用户需要的接口。

  [![img](https://camo.githubusercontent.com/3ffd7a63f2ff4110df701d6be7bd88dce0de8031d76f57d2e76efbf22599dc1f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33643562383238652d356334642d343864382d613434302d3238316534613865316339322e706e67)](https://camo.githubusercontent.com/3ffd7a63f2ff4110df701d6be7bd88dce0de8031d76f57d2e76efbf22599dc1f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33643562383238652d356334642d343864382d613434302d3238316534613865316339322e706e67)

  

  ### Class Diagram

  ![类适配器模式的结构图](http://c.biancheng.net/uploads/allimg/181115/3-1Q1151045351c.gif)

  

  ### Implementation

  鸭子（Duck）和火鸡（Turkey）拥有不同的叫声，Duck 的叫声调用 quack() 方法，而 Turkey 调用 gobble() 方法。

  要求将 Turkey 的 gobble() 方法适配成 Duck 的 quack() 方法，从而让火鸡冒充鸭子！

  ```
  public interface Duck {
      void quack();
  }
  public interface Turkey {
      void gobble();
  }
  public class WildTurkey implements Turkey {
      @Override
      public void gobble() {
          System.out.println("gobble!");
      }
  }
  public class TurkeyAdapter implements Duck {
      Turkey turkey;
  
      public TurkeyAdapter(Turkey turkey) {
          this.turkey = turkey;
      }
  
      @Override
      public void quack() {
          turkey.gobble();
      }
  }
  public class Client {
      public static void main(String[] args) {
          Turkey turkey = new WildTurkey();
          Duck duck = new TurkeyAdapter(turkey);
          duck.quack();
      }
  }
  ```

  ### JDK

  - [java.util.Arrays#asList()](http://docs.oracle.com/javase/8/docs/api/java/util/Arrays.html#asList(T...))
  - [java.util.Collections#list()](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#list-java.util.Enumeration-)
  - [java.util.Collections#enumeration()](https://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#enumeration-java.util.Collection-)
  - [javax.xml.bind.annotation.adapters.XMLAdapter](http://docs.oracle.com/javase/8/docs/api/javax/xml/bind/annotation/adapters/XmlAdapter.html#marshal-BoundType-)

  #### Android

  * Android 源码中的适配器模式（ListView 或 RecyclerView的Adapter）

  

- **桥接模式**

  ### Intent

  将抽象与实现分离开来，使它们可以独立变化。

  ### Class Diagram

  - Abstraction：定义抽象类的接口
  - Implementor：定义实现类接口

  [![img](https://camo.githubusercontent.com/3447042e07134164717533acdf76db331d6ae2b9ebae1bd227b48c491d2a1562/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32613166386230662d316464372d343430392d623137372d6133383163353830363661642e706e67)](https://camo.githubusercontent.com/3447042e07134164717533acdf76db331d6ae2b9ebae1bd227b48c491d2a1562/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32613166386230662d316464372d343430392d623137372d6133383163353830363661642e706e67)

  

  ### Implementation

  RemoteControl 表示遥控器，指代 Abstraction。

  TV 表示电视，指代 Implementor。

  桥接模式将遥控器和电视分离开来，从而可以独立改变遥控器或者电视的实现。

  ```
  public abstract class TV {
      public abstract void on();
  
      public abstract void off();
  
      public abstract void tuneChannel();
  }
  
  public class Sony extends TV {
      @Override
      public void on() {
          System.out.println("Sony.on()");
      }
  
      @Override
      public void off() {
          System.out.println("Sony.off()");
      }
  
      @Override
      public void tuneChannel() {
          System.out.println("Sony.tuneChannel()");
      }
  }
  
  public class RCA extends TV {
      @Override
      public void on() {
          System.out.println("RCA.on()");
      }
  
      @Override
      public void off() {
          System.out.println("RCA.off()");
      }
  
      @Override
      public void tuneChannel() {
          System.out.println("RCA.tuneChannel()");
      }
  }
  
  public abstract class RemoteControl {
      protected TV tv;
  
      public RemoteControl(TV tv) {
          this.tv = tv;
      }
  
      public abstract void on();
  
      public abstract void off();
  
      public abstract void tuneChannel();
  }
  
  public class ConcreteRemoteControl1 extends RemoteControl {
      public ConcreteRemoteControl1(TV tv) {
          super(tv);
      }
  
      @Override
      public void on() {
          System.out.println("ConcreteRemoteControl1.on()");
          tv.on();
      }
  
      @Override
      public void off() {
          System.out.println("ConcreteRemoteControl1.off()");
          tv.off();
      }
  
      @Override
      public void tuneChannel() {
          System.out.println("ConcreteRemoteControl1.tuneChannel()");
          tv.tuneChannel();
      }
  }
  
  public class ConcreteRemoteControl2 extends RemoteControl {
      public ConcreteRemoteControl2(TV tv) {
          super(tv);
      }
  
      @Override
      public void on() {
          System.out.println("ConcreteRemoteControl2.on()");
          tv.on();
      }
  
      @Override
      public void off() {
          System.out.println("ConcreteRemoteControl2.off()");
          tv.off();
      }
  
      @Override
      public void tuneChannel() {
          System.out.println("ConcreteRemoteControl2.tuneChannel()");
          tv.tuneChannel();
      }
  }
  
  public class Client {
      public static void main(String[] args) {
          RemoteControl remoteControl1 = new ConcreteRemoteControl1(new RCA());
          remoteControl1.on();
          remoteControl1.off();
          remoteControl1.tuneChannel();
          RemoteControl remoteControl2 = new ConcreteRemoteControl2(new Sony());
           remoteControl2.on();
           remoteControl2.off();
           remoteControl2.tuneChannel();
      }
  }
  ```

  ### JDK

  - AWT (It provides an abstraction layer which maps onto the native OS the windowing support.)
  - JDBC

  

- **组合模式**

  ### Intent

  将对象组合成树形结构来表示“整体/部分”层次关系，允许用户以相同的方式处理单独对象和组合对象。

  ### Class Diagram

  组件（Component）类是组合类（Composite）和叶子类（Leaf）的父类，可以把组合类看成是树的中间节点。

  组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。

  [![img](https://camo.githubusercontent.com/ca5bbd87bb2dbcc315b40973330cd936c9c180d5cd4537f8a5c53ec24fdd56bf/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32623862666435372d623464312d346137352d626662302d6263663166626134303134612e706e67)](https://camo.githubusercontent.com/ca5bbd87bb2dbcc315b40973330cd936c9c180d5cd4537f8a5c53ec24fdd56bf/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32623862666435372d623464312d346137352d626662302d6263663166626134303134612e706e67)

  

  ### Implementation

  ```java
  public abstract class Component {
      protected String name;
  
      public Component(String name) {
          this.name = name;
      }
  
      public void print() {
          print(0);
      }
  
      abstract void print(int level);
  
      abstract public void add(Component component);
  
      abstract public void remove(Component component);
  }
  
  public class Composite extends Component {
  
      private List<Component> child;
  
      public Composite(String name) {
          super(name);
          child = new ArrayList<>();
      }
  
      @Override
      void print(int level) {
          for (int i = 0; i < level; i++) {
              System.out.print("--");
          }
          System.out.println("Composite:" + name);
          for (Component component : child) {
              component.print(level + 1);
          }
      }
  
      @Override
      public void add(Component component) {
          child.add(component);
      }
  
      @Override
      public void remove(Component component) {
          child.remove(component);
      }
  }
  
  public class Leaf extends Component {
      public Leaf(String name) {
          super(name);
      }
  
      @Override
      void print(int level) {
          for (int i = 0; i < level; i++) {
              System.out.print("--");
          }
          System.out.println("left:" + name);
      }
  
      @Override
      public void add(Component component) {
          throw new UnsupportedOperationException(); // 牺牲透明性换取单一职责原则，这样就不用考虑是叶子节点还是组合节点
      }
  
      @Override
      public void remove(Component component) {
          throw new UnsupportedOperationException();
      }
  }
  
  public class Client {
      public static void main(String[] args) {
          Composite root = new Composite("root");
          Component node1 = new Leaf("1");
          Component node2 = new Composite("2");
          Component node3 = new Leaf("3");
          root.add(node1);
          root.add(node2);
          root.add(node3);
          Component node21 = new Leaf("21");
          Component node22 = new Composite("22");
          node2.add(node21);
          node2.add(node22);
          Component node221 = new Leaf("221");
          node22.add(node221);
          root.print();
      }
  }
  
  Composite:root
  --left:1
  --Composite:2
  ----left:21
  ----Composite:22
  ------left:221
  --left:3
  ```

  ### Android

  * ViewGroup 和 View

  

- **装饰模式**

  ### Intent

  为对象动态添加功能。

  ### Class Diagram

  装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component），具体组件的方法实现不需要依赖于其它对象，而装饰者组合了一个组件，这样它可以装饰其它装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最低层，因为只有具体组件的方法实现不需要依赖于其它对象。

  [![img](https://camo.githubusercontent.com/c07baa58bbb31373fb1195601699866ad279123932f9369605a91eb5544e09d4/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36623833336263322d353137612d343237302d386135652d3061356636646638636439362e706e67)](https://camo.githubusercontent.com/c07baa58bbb31373fb1195601699866ad279123932f9369605a91eb5544e09d4/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f36623833336263322d353137612d343237302d386135652d3061356636646638636439362e706e67)

  

  ### Implementation

  设计不同种类的饮料，饮料可以添加配料，比如可以添加牛奶，并且支持动态添加新配料。每增加一种配料，该饮料的价格就会增加，要求计算一种饮料的价格。

  下图表示在 DarkRoast 饮料上新增新添加 Mocha 配料，之后又添加了 Whip 配料。DarkRoast 被 Mocha 包裹，Mocha 又被 Whip 包裹。它们都继承自相同父类，都有 cost() 方法，外层类的 cost() 方法调用了内层类的 cost() 方法。

  [![img](https://camo.githubusercontent.com/e799845b970fd21fb04e4f7f4f1fa684186e03347bba91de7b4a8a3bc6ce0cd6/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63396366643630302d626339312d346633612d396639392d6234326638386135626232342e6a7067)](https://camo.githubusercontent.com/e799845b970fd21fb04e4f7f4f1fa684186e03347bba91de7b4a8a3bc6ce0cd6/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63396366643630302d626339312d346633612d396639392d6234326638386135626232342e6a7067)

  

  ```
  public interface Beverage {
      double cost();
  }
  public class DarkRoast implements Beverage {
      @Override
      public double cost() {
          return 1;
      }
  }
  public class HouseBlend implements Beverage {
      @Override
      public double cost() {
          return 1;
      }
  }
  public abstract class CondimentDecorator implements Beverage {
      protected Beverage beverage;
  }
  public class Milk extends CondimentDecorator {
  
      public Milk(Beverage beverage) {
          this.beverage = beverage;
      }
  
      @Override
      public double cost() {
          return 1 + beverage.cost();
      }
  }
  public class Mocha extends CondimentDecorator {
  
      public Mocha(Beverage beverage) {
          this.beverage = beverage;
      }
  
      @Override
      public double cost() {
          return 1 + beverage.cost();
      }
  }
  public class Client {
  
      public static void main(String[] args) {
          Beverage beverage = new HouseBlend();
          beverage = new Mocha(beverage);
          beverage = new Milk(beverage);
          System.out.println(beverage.cost());
      }
  }
  3.0
  ```

  ### 设计原则

  类应该对扩展开放，对修改关闭：也就是添加新功能时不需要修改代码。饮料可以动态添加新的配料，而不需要去修改饮料的代码。

  不可能把所有的类设计成都满足这一原则，应当把该原则应用于最有可能发生改变的地方。

  ### Android

  * Context 和 ContextImpl

  

- **外观模式**

  ### Intent

  提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。

  ### Class Diagram

  [![img](https://camo.githubusercontent.com/2b140d7cd28a2c7da7ab30379fc682f73c446a5d1cb63fd8b0b8323b9da4ac86/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66393937386661362d396634392d346130662d383534302d3032643236396163343438662e706e67)](https://camo.githubusercontent.com/2b140d7cd28a2c7da7ab30379fc682f73c446a5d1cb63fd8b0b8323b9da4ac86/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66393937386661362d396634392d346130662d383534302d3032643236396163343438662e706e67)

  

  ### Implementation

  观看电影需要操作很多电器，使用外观模式实现一键看电影功能。

  ```
  public class SubSystem {
      public void turnOnTV() {
          System.out.println("turnOnTV()");
      }
  
      public void setCD(String cd) {
          System.out.println("setCD( " + cd + " )");
      }
  
      public void startWatching(){
          System.out.println("startWatching()");
      }
  }
  public class Facade {
      private SubSystem subSystem = new SubSystem();
  
      public void watchMovie() {
          subSystem.turnOnTV();
          subSystem.setCD("a movie");
          subSystem.startWatching();
      }
  }
  public class Client {
      public static void main(String[] args) {
          Facade facade = new Facade();
          facade.watchMovie();
      }
  }
  ```

  ### 设计原则

  最少知识原则：只和你的密友谈话。也就是说客户对象所需要交互的对象应当尽可能少。

  ### Android

  * Android源码中的外观模式（ContextImpl）

  

- **享元模式（Flyweight）** -- 缓存

  ### Intent

  利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。

  ### Class Diagram

  - Flyweight：享元对象
  - IntrinsicState：内部状态，享元对象共享内部状态
  - ExtrinsicState：外部状态，每个享元对象的外部状态不同

  [![img](https://camo.githubusercontent.com/56f655515966d04fe046326df71b7a6824157cc6e070311ffb2f4554bb287bfc/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35663563323264352d396330652d343965312d623562302d3663633730333237323464342e706e67)](https://camo.githubusercontent.com/56f655515966d04fe046326df71b7a6824157cc6e070311ffb2f4554bb287bfc/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35663563323264352d396330652d343965312d623562302d3663633730333237323464342e706e67)

  

  ### Implementation

  ```java
  public interface Flyweight {
      void doOperation(String extrinsicState);
  }
  public class ConcreteFlyweight implements Flyweight {
  
      private String intrinsicState;
  
      public ConcreteFlyweight(String intrinsicState) {
          this.intrinsicState = intrinsicState;
      }
  
      @Override
      public void doOperation(String extrinsicState) {
          System.out.println("Object address: " + System.identityHashCode(this));
          System.out.println("IntrinsicState: " + intrinsicState);
          System.out.println("ExtrinsicState: " + extrinsicState);
      }
  }
  public class FlyweightFactory {
  
      private HashMap<String, Flyweight> flyweights = new HashMap<>();
  
      Flyweight getFlyweight(String intrinsicState) {
          if (!flyweights.containsKey(intrinsicState)) {
              Flyweight flyweight = new ConcreteFlyweight(intrinsicState);
              flyweights.put(intrinsicState, flyweight);
          }
          return flyweights.get(intrinsicState);
      }
  }
  public class Client {
  
      public static void main(String[] args) {
          FlyweightFactory factory = new FlyweightFactory();
          Flyweight flyweight1 = factory.getFlyweight("aa");
          Flyweight flyweight2 = factory.getFlyweight("aa");
          flyweight1.doOperation("x");
          flyweight2.doOperation("y");
      }
  }
  Object address: 1163157884
  IntrinsicState: aa
  ExtrinsicState: x
  Object address: 1163157884
  IntrinsicState: aa
  ExtrinsicState: y
  ```

  

  ### Android 

  * Android源码中的享元模式（Android中的Handler Message）

  

  

- **代理模式**

  ### Intent

  控制对其它对象的访问。

  ### Class Diagram

  代理有以下四类：

  - 远程代理（Remote Proxy）：控制对远程对象（不同地址空间）的访问，它负责将请求及其参数进行编码，并向不同地址空间中的对象发送已经编码的请求。
  - 虚拟代理（Virtual Proxy）：根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。
  - 保护代理（Protection Proxy）：按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。
  - 智能代理（Smart Reference）：取代了简单的指针，它在访问对象时执行一些附加操作：记录对象的引用次数；当第一次引用一个对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其它对象不能改变它。

  [![img](https://camo.githubusercontent.com/eb56a06d8471ffca380c9b01b8a11a1db309ac21852210e60bf80341601c7758/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39623637396666352d393463362d343861372d623962372d3265613836386538323865642e706e67)](https://camo.githubusercontent.com/eb56a06d8471ffca380c9b01b8a11a1db309ac21852210e60bf80341601c7758/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39623637396666352d393463362d343861372d623962372d3265613836386538323865642e706e67)

  

  ### Implementation

  以下是一个虚拟代理的实现，模拟了图片延迟加载的情况下使用与图片大小相等的临时内容去替换原始图片，直到图片加载完成才将图片显示出来。

  ```java
  public interface Image {
      void showImage();
  }
  
  public class HighResolutionImage implements Image {
  
      private URL imageURL;
      private long startTime;
      private int height;
      private int width;
  
      public int getHeight() {
          return height;
      }
  
      public int getWidth() {
          return width;
      }
  
      public HighResolutionImage(URL imageURL) {
          this.imageURL = imageURL;
          this.startTime = System.currentTimeMillis();
          this.width = 600;
          this.height = 600;
      }
  
      public boolean isLoad() {
          // 模拟图片加载，延迟 3s 加载完成
          long endTime = System.currentTimeMillis();
          return endTime - startTime > 3000;
      }
  
      @Override
      public void showImage() {
          System.out.println("Real Image: " + imageURL);
      }
  }
  
  public class ImageProxy implements Image {
  
      private HighResolutionImage highResolutionImage;
  
      public ImageProxy(HighResolutionImage highResolutionImage) {
          this.highResolutionImage = highResolutionImage;
      }
  
      @Override
      public void showImage() {
          while (!highResolutionImage.isLoad()) {
              try {
                  System.out.println("Temp Image: " + highResolutionImage.getWidth() + " " + highResolutionImage.getHeight());
                  Thread.sleep(100);
              } catch (InterruptedException e) {
                  e.printStackTrace();
              }
          }
          highResolutionImage.showImage();
      }
  }
  
  public class ImageViewer {
  
      public static void main(String[] args) throws Exception {
          String image = "http://image.jpg";
          URL url = new URL(image);
          HighResolutionImage highResolutionImage = new HighResolutionImage(url);
          ImageProxy imageProxy = new ImageProxy(highResolutionImage);
          imageProxy.showImage();
      }
  }
  ```

  ### Android

  * Android源码中的代理模式实现（ActivityManagerProxy代理类）





### 行为型模式

- **责任链模式**

  ### Intent

  使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。

  ### Class Diagram

  - Handler：定义处理请求的接口，并且实现后继链（successor）

  [![img](https://camo.githubusercontent.com/4d57a357b768a4e0b6a69322b2e4f3069e95d7d9bfca772a9009a301194fbd6a/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63613966323362662d353561342d343762322d393533342d6132386533353339373938382e706e67)](https://camo.githubusercontent.com/4d57a357b768a4e0b6a69322b2e4f3069e95d7d9bfca772a9009a301194fbd6a/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63613966323362662d353561342d343762322d393533342d6132386533353339373938382e706e67)

  

  ### Implementation

  ```java
  public abstract class Handler {
  
      protected Handler successor;
  
  
      public Handler(Handler successor) {
          this.successor = successor;
      }
  
  
      protected abstract void handleRequest(Request request);
  }
  public class ConcreteHandler1 extends Handler {
  
      public ConcreteHandler1(Handler successor) {
          super(successor);
      }
  
  
      @Override
      protected void handleRequest(Request request) {
          if (request.getType() == RequestType.TYPE1) {
              System.out.println(request.getName() + " is handle by ConcreteHandler1");
              return;
          }
          if (successor != null) {
              successor.handleRequest(request);
          }
      }
  }
  public class ConcreteHandler2 extends Handler {
  
      public ConcreteHandler2(Handler successor) {
          super(successor);
      }
  
  
      @Override
      protected void handleRequest(Request request) {
          if (request.getType() == RequestType.TYPE2) {
              System.out.println(request.getName() + " is handle by ConcreteHandler2");
              return;
          }
          if (successor != null) {
              successor.handleRequest(request);
          }
      }
  }
  public class Request {
  
      private RequestType type;
      private String name;
  
  
      public Request(RequestType type, String name) {
          this.type = type;
          this.name = name;
      }
  
  
      public RequestType getType() {
          return type;
      }
  
  
      public String getName() {
          return name;
      }
  }
  public enum RequestType {
      TYPE1, TYPE2
  }
  public class Client {
  
      public static void main(String[] args) {
  
          Handler handler1 = new ConcreteHandler1(null);
          Handler handler2 = new ConcreteHandler2(handler1);
  
          Request request1 = new Request(RequestType.TYPE1, "request1");
          handler2.handleRequest(request1);
  
          Request request2 = new Request(RequestType.TYPE2, "request2");
          handler2.handleRequest(request2);
      }
  }
  request1 is handle by ConcreteHandler1
  request2 is handle by ConcreteHandler2
  ```

  ### Android

  * Android源码中的责任链模式实现（ViewGroup中事件派发）

  

- **命令模式**

  ### Intent

  将命令封装成对象中，具有以下作用：

  - 使用命令来参数化其它对象

  - 将命令放入队列中进行排队

  - 将命令的操作记录到日志中

  - 支持可撤销的操作

    

  ### Class Diagram

  - Command：命令
  - Receiver：命令接收者，也就是命令真正的执行者
  - Invoker：通过它来调用命令
  - Client：可以设置命令与命令的接收者

  [![img](https://camo.githubusercontent.com/66f5b5e34558ea1084cfc3867c1319f1991847cd7d484fe95379531b87e67ac5/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63343461303334322d663430352d346631372d623735302d6532376366346161646465322e706e67)](https://camo.githubusercontent.com/66f5b5e34558ea1084cfc3867c1319f1991847cd7d484fe95379531b87e67ac5/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63343461303334322d663430352d346631372d623735302d6532376366346161646465322e706e67)

  

  ### Implementation

  设计一个遥控器，可以控制电灯开关。

  [![img](https://camo.githubusercontent.com/49170973462fd9c43685e2b6e412068c805c0812e940e3d1643bd36b1826004e/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65366264656438652d343161302d343839612d383861362d3633386538386162373636362e6a7067)](https://camo.githubusercontent.com/49170973462fd9c43685e2b6e412068c805c0812e940e3d1643bd36b1826004e/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65366264656438652d343161302d343839612d383861362d3633386538386162373636362e6a7067)

  

  ```java
  public interface Command {
      void execute();
  }
  public class LightOnCommand implements Command {
      Light light;
  
      public LightOnCommand(Light light) {
          this.light = light;
      }
  
      @Override
      public void execute() {
          light.on();
      }
  }
  public class LightOffCommand implements Command {
      Light light;
  
      public LightOffCommand(Light light) {
          this.light = light;
      }
  
      @Override
      public void execute() {
          light.off();
      }
  }
  public class Light {
  
      public void on() {
          System.out.println("Light is on!");
      }
  
      public void off() {
          System.out.println("Light is off!");
      }
  }
  /**
   * 遥控器
   */
  public class Invoker {
      private Command[] onCommands;
      private Command[] offCommands;
      private final int slotNum = 7;
  
      public Invoker() {
          this.onCommands = new Command[slotNum];
          this.offCommands = new Command[slotNum];
      }
  
      public void setOnCommand(Command command, int slot) {
          onCommands[slot] = command;
      }
  
      public void setOffCommand(Command command, int slot) {
          offCommands[slot] = command;
      }
  
      public void onButtonWasPushed(int slot) {
          onCommands[slot].execute();
      }
  
      public void offButtonWasPushed(int slot) {
          offCommands[slot].execute();
      }
  }
  public class Client {
      public static void main(String[] args) {
          Invoker invoker = new Invoker();
          Light light = new Light();
          Command lightOnCommand = new LightOnCommand(light);
          Command lightOffCommand = new LightOffCommand(light);
          invoker.setOnCommand(lightOnCommand, 0);
          invoker.setOffCommand(lightOffCommand, 0);
          invoker.onButtonWasPushed(0);
          invoker.offButtonWasPushed(0);
      }
  }
  ```

  ### Android

  * Android源码中的命令模式实现（Android事件机制中低层逻辑对事件的转发处理）



- **解释器模式**

  为语言创建解释器，通常由语言的语法和语法分析来定义。

  ### Class Diagram

  - TerminalExpression：终结符表达式，每个终结符都需要一个 TerminalExpression。
  - Context：上下文，包含解释器之外的一些全局信息。

  [![img](https://camo.githubusercontent.com/715d3c333031afac63bfea238bde09eedf3a8289ffc4106f85a6f47b2aa1f2da/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32623132356263642d316233362d343362652d396237382d6439306230373662653534392e706e67)](https://camo.githubusercontent.com/715d3c333031afac63bfea238bde09eedf3a8289ffc4106f85a6f47b2aa1f2da/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f32623132356263642d316233362d343362652d396237382d6439306230373662653534392e706e67)

  

  ### Implementation

  以下是一个规则检验器实现，具有 and 和 or 规则，通过规则可以构建一颗解析树，用来检验一个文本是否满足解析树定义的规则。

  例如一颗解析树为 D And (A Or (B C))，文本 "D A" 满足该解析树定义的规则。

  这里的 Context 指的是 String。

  ```java
  public abstract class Expression {
      public abstract boolean interpret(String str);
  }
  public class TerminalExpression extends Expression {
  
      private String literal = null;
  
      public TerminalExpression(String str) {
          literal = str;
      }
  
      public boolean interpret(String str) {
          StringTokenizer st = new StringTokenizer(str);
          while (st.hasMoreTokens()) {
              String test = st.nextToken();
              if (test.equals(literal)) {
                  return true;
              }
          }
          return false;
      }
  }
  public class AndExpression extends Expression {
  
      private Expression expression1 = null;
      private Expression expression2 = null;
  
      public AndExpression(Expression expression1, Expression expression2) {
          this.expression1 = expression1;
          this.expression2 = expression2;
      }
  
      public boolean interpret(String str) {
          return expression1.interpret(str) && expression2.interpret(str);
      }
  }
  public class OrExpression extends Expression {
      private Expression expression1 = null;
      private Expression expression2 = null;
  
      public OrExpression(Expression expression1, Expression expression2) {
          this.expression1 = expression1;
          this.expression2 = expression2;
      }
  
      public boolean interpret(String str) {
          return expression1.interpret(str) || expression2.interpret(str);
      }
  }
  public class Client {
  
      /**
       * 构建解析树
       */
      public static Expression buildInterpreterTree() {
          // Literal
          Expression terminal1 = new TerminalExpression("A");
          Expression terminal2 = new TerminalExpression("B");
          Expression terminal3 = new TerminalExpression("C");
          Expression terminal4 = new TerminalExpression("D");
          // B C
          Expression alternation1 = new OrExpression(terminal2, terminal3);
          // A Or (B C)
          Expression alternation2 = new OrExpression(terminal1, alternation1);
          // D And (A Or (B C))
          return new AndExpression(terminal4, alternation2);
      }
  
      public static void main(String[] args) {
          Expression define = buildInterpreterTree();
          String context1 = "D A";
          String context2 = "A B";
          System.out.println(define.interpret(context1));
          System.out.println(define.interpret(context2));
      }
  }
  true
  false
  ```

  

- **迭代器模式**

  ### Intent

  提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。

  ### Class Diagram

  - Aggregate 是聚合类，其中 createIterator() 方法可以产生一个 Iterator；
  - Iterator 主要定义了 hasNext() 和 next() 方法；
  - Client 组合了 Aggregate，为了迭代遍历 Aggregate，也需要组合 Iterator。

  [![image-20191130164425351](https://camo.githubusercontent.com/2222982860cc5dd633c46c006222eda256b12358576794c73c3ae4e8cc8bfbcd/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303230313130323031323333333830342e706e67)](https://camo.githubusercontent.com/2222982860cc5dd633c46c006222eda256b12358576794c73c3ae4e8cc8bfbcd/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f696d6167652d32303230313130323031323333333830342e706e67)

  

  ### Implementation

  ```java
  public interface Aggregate {
      Iterator createIterator();
  }
  public class ConcreteAggregate implements Aggregate {
  
      private Integer[] items;
  
      public ConcreteAggregate() {
          items = new Integer[10];
          for (int i = 0; i < items.length; i++) {
              items[i] = i;
          }
      }
  
      @Override
      public Iterator createIterator() {
          return new ConcreteIterator<Integer>(items);
      }
  }
  public interface Iterator<Item> {
  
      Item next();
  
      boolean hasNext();
  }
  public class ConcreteIterator<Item> implements Iterator {
  
      private Item[] items;
      private int position = 0;
  
      public ConcreteIterator(Item[] items) {
          this.items = items;
      }
  
      @Override
      public Object next() {
          return items[position++];
      }
  
      @Override
      public boolean hasNext() {
          return position < items.length;
      }
  }
  public class Client {
  
      public static void main(String[] args) {
          Aggregate aggregate = new ConcreteAggregate();
          Iterator<Integer> iterator = aggregate.createIterator();
          while (iterator.hasNext()) {
              System.out.println(iterator.next());
          }
      }
  }
  ```

  

  ### Android

  * Android源码中的模式实现（SQLiteDatabase的query方法查询数据库时，返回的Cursor游标对象，实质就是一个具体的迭代器）



- **中介者模式**

  ### Intent

  集中相关对象之间复杂的沟通和控制方式。

  ### Class Diagram

  - Mediator：中介者，定义一个接口用于与各同事（Colleague）对象通信。
  - Colleague：同事，相关对象

  ![img](https://camo.githubusercontent.com/87dcb5ef200c909733e3aaf99d023b4aca43164d911bcd9ebdc9477d99b24f6e/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33306436653935632d326533632d346433322d626634662d3638313238613730626330352e706e67)

  ### Implementation

  Alarm（闹钟）、CoffeePot（咖啡壶）、Calendar（日历）、Sprinkler（喷头）是一组相关的对象，在某个对象的事件产生时需要去操作其它对象，形成了下面这种依赖结构：

  ![img](https://camo.githubusercontent.com/e03bfde35a4ab44dfa66428f801f6bf272c2d90b57d40fd4a7904680913f20b8/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38326366646133622d623533622d346338392d396664622d3236646432646230636430322e6a7067)

  使用中介者模式可以将复杂的依赖结构变成星形结构：

  ![img](https://camo.githubusercontent.com/ded6201e4b22beb45c25db0b0a126883918249004f40873065a0978fc83bc55b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35333539636266352d356137392d343837342d396231372d6632336335336332636238302e6a7067)

  

  ```java
  public abstract class Colleague {
      public abstract void onEvent(Mediator mediator);
  }
  public class Alarm extends Colleague {
  
      @Override
      public void onEvent(Mediator mediator) {
          mediator.doEvent("alarm");
      }
  
      public void doAlarm() {
          System.out.println("doAlarm()");
      }
  }
  public class CoffeePot extends Colleague {
      @Override
      public void onEvent(Mediator mediator) {
          mediator.doEvent("coffeePot");
      }
  
      public void doCoffeePot() {
          System.out.println("doCoffeePot()");
      }
  }
  public class Calender extends Colleague {
      @Override
      public void onEvent(Mediator mediator) {
          mediator.doEvent("calender");
      }
  
      public void doCalender() {
          System.out.println("doCalender()");
      }
  }
  public class Sprinkler extends Colleague {
      @Override
      public void onEvent(Mediator mediator) {
          mediator.doEvent("sprinkler");
      }
  
      public void doSprinkler() {
          System.out.println("doSprinkler()");
      }
  }
  
  public abstract class Mediator {
      public abstract void doEvent(String eventType);
  }
  
  public class ConcreteMediator extends Mediator {
      private Alarm alarm;
      private CoffeePot coffeePot;
      private Calender calender;
      private Sprinkler sprinkler;
  
      public ConcreteMediator(Alarm alarm, CoffeePot coffeePot, Calender calender, Sprinkler sprinkler) {
          this.alarm = alarm;
          this.coffeePot = coffeePot;
          this.calender = calender;
          this.sprinkler = sprinkler;
      }
  
      @Override
      public void doEvent(String eventType) {
          switch (eventType) {
              case "alarm":
                  doAlarmEvent();
                  break;
              case "coffeePot":
                  doCoffeePotEvent();
                  break;
              case "calender":
                  doCalenderEvent();
                  break;
              default:
                  doSprinklerEvent();
          }
      }
  
      public void doAlarmEvent() {
          alarm.doAlarm();
          coffeePot.doCoffeePot();
          calender.doCalender();
          sprinkler.doSprinkler();
      }
  
      public void doCoffeePotEvent() {
          // ...
      }
  
      public void doCalenderEvent() {
          // ...
      }
  
      public void doSprinklerEvent() {
          // ...
      }
  }
  
  public class Client {
      public static void main(String[] args) {
          Alarm alarm = new Alarm();
          CoffeePot coffeePot = new CoffeePot();
          Calender calender = new Calender();
          Sprinkler sprinkler = new Sprinkler();
          Mediator mediator = new ConcreteMediator(alarm, coffeePot, calender, sprinkler);
          // 闹钟事件到达，调用中介者就可以操作相关对象
          alarm.onEvent(mediator);
      }
  }
  
  doAlarm()
  doCoffeePot()
  doCalender()
  doSprinkler()
  ```

  ### Android

  * Android源码中的中介者模式实现（Keyguard锁屏）



- **备忘录模式**

  ### Intent

  在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。

  ### Class Diagram

  - Originator：原始对象
  - Caretaker：负责保存好备忘录
  - Memento：备忘录，存储原始对象的状态。备忘录实际上有两个接口，一个是提供给 Caretaker 的窄接口：它只能将备忘录传递给其它对象；一个是提供给 Originator 的宽接口，允许它访问到先前状态所需的所有数据。理想情况是只允许 Originator 访问本备忘录的内部状态。

  [![img](https://camo.githubusercontent.com/e7275e07474235146a418492e41145f0a03bf04087ee53cb5e8a6c37256873a8/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35303637386633342d363934662d343561342d393163362d3334643938356338336665652e706e67)](https://camo.githubusercontent.com/e7275e07474235146a418492e41145f0a03bf04087ee53cb5e8a6c37256873a8/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35303637386633342d363934662d343561342d393163362d3334643938356338336665652e706e67)

  

  ### Implementation

  以下实现了一个简单计算器程序，可以输入两个值，然后计算这两个值的和。备忘录模式允许将这两个值存储起来，然后在某个时刻用存储的状态进行恢复。

  实现参考：[Memento Pattern - Calculator Example - Java Sourcecode](https://www.oodesign.com/memento-pattern-calculator-example-java-sourcecode.html)

  ```java
  /**
   * Originator Interface
   */
  public interface Calculator {
  
      // Create Memento
      PreviousCalculationToCareTaker backupLastCalculation();
  
      // setMemento
      void restorePreviousCalculation(PreviousCalculationToCareTaker memento);
  
      int getCalculationResult();
  
      void setFirstNumber(int firstNumber);
  
      void setSecondNumber(int secondNumber);
  }
  
  /**
   * Originator Implementation
   */
  public class CalculatorImp implements Calculator {
  
      private int firstNumber;
      private int secondNumber;
  
      @Override
      public PreviousCalculationToCareTaker backupLastCalculation() {
          // create a memento object used for restoring two numbers
          return new PreviousCalculationImp(firstNumber, secondNumber);
      }
  
      @Override
      public void restorePreviousCalculation(PreviousCalculationToCareTaker memento) {
          this.firstNumber = ((PreviousCalculationToOriginator) memento).getFirstNumber();
          this.secondNumber = ((PreviousCalculationToOriginator) memento).getSecondNumber();
      }
  
      @Override
      public int getCalculationResult() {
          // result is adding two numbers
          return firstNumber + secondNumber;
      }
  
      @Override
      public void setFirstNumber(int firstNumber) {
          this.firstNumber = firstNumber;
      }
  
      @Override
      public void setSecondNumber(int secondNumber) {
          this.secondNumber = secondNumber;
      }
  }
  
  /**
   * Memento Interface to Originator
   *
   * This interface allows the originator to restore its state
   */
  public interface PreviousCalculationToOriginator {
      int getFirstNumber();
      int getSecondNumber();
  }
  
  /**
   *  Memento interface to CalculatorOperator (Caretaker)
   */
  public interface PreviousCalculationToCareTaker {
      // no operations permitted for the caretaker
  }
  
  /**
   * Memento Object Implementation
   * <p>
   * Note that this object implements both interfaces to Originator and CareTaker
   */
  public class PreviousCalculationImp implements PreviousCalculationToCareTaker,
          PreviousCalculationToOriginator {
  
      private int firstNumber;
      private int secondNumber;
  
      public PreviousCalculationImp(int firstNumber, int secondNumber) {
          this.firstNumber = firstNumber;
          this.secondNumber = secondNumber;
      }
  
      @Override
      public int getFirstNumber() {
          return firstNumber;
      }
  
      @Override
      public int getSecondNumber() {
          return secondNumber;
      }
  }
  
  /**
   * CareTaker object
   */
  public class Client {
  
      public static void main(String[] args) {
          // program starts
          Calculator calculator = new CalculatorImp();
  
          // assume user enters two numbers
          calculator.setFirstNumber(10);
          calculator.setSecondNumber(100);
  
          // find result
          System.out.println(calculator.getCalculationResult());
  
          // Store result of this calculation in case of error
          PreviousCalculationToCareTaker memento = calculator.backupLastCalculation();
  
          // user enters a number
          calculator.setFirstNumber(17);
  
          // user enters a wrong second number and calculates result
          calculator.setSecondNumber(-290);
  
          // calculate result
          System.out.println(calculator.getCalculationResult());
  
          // user hits CTRL + Z to undo last operation and see last result
          calculator.restorePreviousCalculation(memento);
  
          // result restored
          System.out.println(calculator.getCalculationResult());
      }
  }
  
  110
  -273
  110
  ```

  ### Android

  * Android源码中的备忘录模式  （Activity中的状态保存）

  

- **观察者模式**

  ### Intent

  定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。

  主题（Subject）是被观察的对象，而其所有依赖者（Observer）称为观察者。

  ![img](https://camo.githubusercontent.com/c8cfab4eda242b8b6d1d05545578451e00139c45fc3500d175fd95d40950241d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37613363366133302d633733352d346564622d383131352d3333373238386134663066322e6a7067)

  

  ### Class Diagram

  主题（Subject）具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。

  观察者（Observer）的注册功能需要调用主题的 registerObserver() 方法。

  ![img](https://camo.githubusercontent.com/1ddd7e42220b66f857de39c6731ba37b54ceea0c187d2c51f8691267e171a923/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61386338663839342d613731322d343437632d393930362d3563616566366130313665332e706e67)

  

  ### Implementation

  天气数据布告板会在天气信息发生改变时更新其内容，布告板有多个，并且在将来会继续增加。

  ![img](https://camo.githubusercontent.com/dce5c2f8b95edf0ed7bec820e29fdcd4a779d5a72f7188f8005fce957611f0a0/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f62316466393733322d383663652d346436392d396630362d6662613164623762336235612e6a7067)

  

  ```java
  public interface Subject {
      void registerObserver(Observer o);
  
      void removeObserver(Observer o);
  
      void notifyObserver();
  }
  
  public class WeatherData implements Subject {
      private List<Observer> observers;
      private float temperature;
      private float humidity;
      private float pressure;
  
      public WeatherData() {
          observers = new ArrayList<>();
      }
  
      public void setMeasurements(float temperature, float humidity, float pressure) {
          this.temperature = temperature;
          this.humidity = humidity;
          this.pressure = pressure;
          notifyObserver();
      }
  
      @Override
      public void registerObserver(Observer o) {
          observers.add(o);
      }
  
      @Override
      public void removeObserver(Observer o) {
          int i = observers.indexOf(o);
          if (i >= 0) {
              observers.remove(i);
          }
      }
  
      @Override
      public void notifyObserver() {
          for (Observer o : observers) {
              o.update(temperature, humidity, pressure);
          }
      }
  }
  
  public interface Observer {
      void update(float temp, float humidity, float pressure);
  }
  
  public class StatisticsDisplay implements Observer {
  
      public StatisticsDisplay(Subject weatherData) {
          weatherData.registerObserver(this);
      }
  
      @Override
      public void update(float temp, float humidity, float pressure) {
          System.out.println("StatisticsDisplay.update: " + temp + " " + humidity + " " + pressure);
      }
  }
  
  public class CurrentConditionsDisplay implements Observer {
  
      public CurrentConditionsDisplay(Subject weatherData) {
          weatherData.registerObserver(this);
      }
  
      @Override
      public void update(float temp, float humidity, float pressure) {
          System.out.println("CurrentConditionsDisplay.update: " + temp + " " + humidity + " " + pressure);
      }
  }
  
  public class WeatherStation {
      public static void main(String[] args) {
          WeatherData weatherData = new WeatherData();
          CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay(weatherData);
          StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);
  
          weatherData.setMeasurements(0, 0, 0);
          weatherData.setMeasurements(1, 1, 1);
      }
  }
  
  CurrentConditionsDisplay.update: 0.0 0.0 0.0
  StatisticsDisplay.update: 0.0 0.0 0.0
  CurrentConditionsDisplay.update: 1.0 1.0 1.0
  StatisticsDisplay.update: 1.0 1.0 1.0
  ```

  

  ### Android

  * Android 源码分析（Adapter的notifyDataSetChanged）
  
  



- **状态模式**

  ### Intent

  允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。

  ### Class Diagram

  [![img](https://camo.githubusercontent.com/526bec9ce98734a8e79b29b8b1181ad3eeb936dd2cbc63d014a6114bdc015701/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37396466383836662d666463332d343032302d613037662d6339393162623538653064382e706e67)](https://camo.githubusercontent.com/526bec9ce98734a8e79b29b8b1181ad3eeb936dd2cbc63d014a6114bdc015701/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37396466383836662d666463332d343032302d613037662d6339393162623538653064382e706e67)

  

  ### Implementation

  糖果销售机有多种状态，每种状态下销售机有不同的行为，状态可以发生转移，使得销售机的行为也发生改变。

  <img src="https://camo.githubusercontent.com/faada3940378b6d49d528de0165d60195896a2d92dae510fb3fce34b4e118518/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f33393662653938312d336632632d346664392d383130312d6462663963383431353034622e6a7067" alt="img" style="zoom:67%;" />

  

  ```java
  public interface State {
      /**
       * 投入 25 分钱
       */
      void insertQuarter();
  
      /**
       * 退回 25 分钱
       */
      void ejectQuarter();
  
      /**
       * 转动曲柄
       */
      void turnCrank();
  
      /**
       * 发放糖果
       */
      void dispense();
  }
  public class HasQuarterState implements State {
  
      private GumballMachine gumballMachine;
  
      public HasQuarterState(GumballMachine gumballMachine) {
          this.gumballMachine = gumballMachine;
      }
  
      @Override
      public void insertQuarter() {
          System.out.println("You can't insert another quarter");
      }
  
      @Override
      public void ejectQuarter() {
          System.out.println("Quarter returned");
          gumballMachine.setState(gumballMachine.getNoQuarterState());
      }
  
      @Override
      public void turnCrank() {
          System.out.println("You turned...");
          gumballMachine.setState(gumballMachine.getSoldState());
      }
  
      @Override
      public void dispense() {
          System.out.println("No gumball dispensed");
      }
  }
  public class NoQuarterState implements State {
  
      GumballMachine gumballMachine;
  
      public NoQuarterState(GumballMachine gumballMachine) {
          this.gumballMachine = gumballMachine;
      }
  
      @Override
      public void insertQuarter() {
          System.out.println("You insert a quarter");
          gumballMachine.setState(gumballMachine.getHasQuarterState());
      }
  
      @Override
      public void ejectQuarter() {
          System.out.println("You haven't insert a quarter");
      }
  
      @Override
      public void turnCrank() {
          System.out.println("You turned, but there's no quarter");
      }
  
      @Override
      public void dispense() {
          System.out.println("You need to pay first");
      }
  }
  public class SoldOutState implements State {
  
      GumballMachine gumballMachine;
  
      public SoldOutState(GumballMachine gumballMachine) {
          this.gumballMachine = gumballMachine;
      }
  
      @Override
      public void insertQuarter() {
          System.out.println("You can't insert a quarter, the machine is sold out");
      }
  
      @Override
      public void ejectQuarter() {
          System.out.println("You can't eject, you haven't inserted a quarter yet");
      }
  
      @Override
      public void turnCrank() {
          System.out.println("You turned, but there are no gumballs");
      }
  
      @Override
      public void dispense() {
          System.out.println("No gumball dispensed");
      }
  }
  public class SoldState implements State {
  
      GumballMachine gumballMachine;
  
      public SoldState(GumballMachine gumballMachine) {
          this.gumballMachine = gumballMachine;
      }
  
      @Override
      public void insertQuarter() {
          System.out.println("Please wait, we're already giving you a gumball");
      }
  
      @Override
      public void ejectQuarter() {
          System.out.println("Sorry, you already turned the crank");
      }
  
      @Override
      public void turnCrank() {
          System.out.println("Turning twice doesn't get you another gumball!");
      }
  
      @Override
      public void dispense() {
          gumballMachine.releaseBall();
          if (gumballMachine.getCount() > 0) {
              gumballMachine.setState(gumballMachine.getNoQuarterState());
          } else {
              System.out.println("Oops, out of gumballs");
              gumballMachine.setState(gumballMachine.getSoldOutState());
          }
      }
  }
  public class GumballMachine {
  
      private State soldOutState;
      private State noQuarterState;
      private State hasQuarterState;
      private State soldState;
  
      private State state;
      private int count = 0;
  
      public GumballMachine(int numberGumballs) {
          count = numberGumballs;
          soldOutState = new SoldOutState(this);
          noQuarterState = new NoQuarterState(this);
          hasQuarterState = new HasQuarterState(this);
          soldState = new SoldState(this);
  
          if (numberGumballs > 0) {
              state = noQuarterState;
          } else {
              state = soldOutState;
          }
      }
  
      public void insertQuarter() {
          state.insertQuarter();
      }
  
      public void ejectQuarter() {
          state.ejectQuarter();
      }
  
      public void turnCrank() {
          state.turnCrank();
          state.dispense();
      }
  
      public void setState(State state) {
          this.state = state;
      }
  
      public void releaseBall() {
          System.out.println("A gumball comes rolling out the slot...");
          if (count != 0) {
              count -= 1;
          }
      }
  
      public State getSoldOutState() {
          return soldOutState;
      }
  
      public State getNoQuarterState() {
          return noQuarterState;
      }
  
      public State getHasQuarterState() {
          return hasQuarterState;
      }
  
      public State getSoldState() {
          return soldState;
      }
  
      public int getCount() {
          return count;
      }
  }
  public class Client {
  
      public static void main(String[] args) {
          GumballMachine gumballMachine = new GumballMachine(5);
  
          gumballMachine.insertQuarter();
          gumballMachine.turnCrank();
  
          gumballMachine.insertQuarter();
          gumballMachine.ejectQuarter();
          gumballMachine.turnCrank();
  
          gumballMachine.insertQuarter();
          gumballMachine.turnCrank();
          gumballMachine.insertQuarter();
          gumballMachine.turnCrank();
          gumballMachine.ejectQuarter();
  
          gumballMachine.insertQuarter();
          gumballMachine.insertQuarter();
          gumballMachine.turnCrank();
          gumballMachine.insertQuarter();
          gumballMachine.turnCrank();
          gumballMachine.insertQuarter();
          gumballMachine.turnCrank();
      }
  }
  ```

  ```java
  You insert a quarter
  You turned...
  A gumball comes rolling out the slot...
  You insert a quarter
  Quarter returned
  You turned, but there's no quarter
  You need to pay first
  You insert a quarter
  You turned...
  A gumball comes rolling out the slot...
  You insert a quarter
  You turned...
  A gumball comes rolling out the slot...
  You haven't insert a quarter
  You insert a quarter
  You can't insert another quarter
  You turned...
  A gumball comes rolling out the slot...
  You insert a quarter
  You turned...
  A gumball comes rolling out the slot...
  Oops, out of gumballs
  You can't insert a quarter, the machine is sold out
  You turned, but there are no gumballs
  No gumball dispensed
  ```

  ### Android

  * Wifi管理中的状态模式

  

  

- **策略模式**

  ### Intent

  定义一系列算法，封装每个算法，并使它们可以互换。

  策略模式可以让算法独立于使用它的客户端。

  ### Class Diagram

  - Strategy 接口定义了一个算法族，它们都实现了 behavior() 方法。
  - Context 是使用到该算法族的类，其中的 doSomething() 方法会调用 behavior()，setStrategy(Strategy) 方法可以动态地改变 strategy 对象，也就是说能动态地改变 Context 所使用的算法。

  ![img](https://camo.githubusercontent.com/927b6522fc00ab79d357438c91ca17336f7f60ee3b1121f7696a16f607ed5021/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f63643162653863322d373535612d346136362d616439322d3265333066386634373932322e706e67)

  

  ### 与状态模式的比较

  状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变 Context 所组合的 State 对象，而策略模式是通过 Context 本身的决策来改变组合的 Strategy 对象。所谓的状态转移，是指 Context 在运行过程中由于一些条件发生改变而使得 State 对象发生改变，注意必须要是在运行过程中。

  状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么 Context 对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换 Context 使用的算法。

  ### Implementation

  设计一个鸭子，它可以动态地改变叫声。这里的算法族是鸭子的叫声行为。

  ```java
  public interface QuackBehavior {
      void quack();
  }
  public class Quack implements QuackBehavior {
      @Override
      public void quack() {
          System.out.println("quack!");
      }
  }
  public class Squeak implements QuackBehavior{
      @Override
      public void quack() {
          System.out.println("squeak!");
      }
  }
  public class Duck {
  
      private QuackBehavior quackBehavior;
  
      public void performQuack() {
          if (quackBehavior != null) {
              quackBehavior.quack();
          }
      }
  
      public void setQuackBehavior(QuackBehavior quackBehavior) {
          this.quackBehavior = quackBehavior;
      }
  }
  public class Client {
  
      public static void main(String[] args) {
          Duck duck = new Duck();
          duck.setQuackBehavior(new Squeak());
          duck.performQuack();
          duck.setQuackBehavior(new Quack());
          duck.performQuack();
      }
  }
  ```

  ```java
  squeak!
  quack!
  ```

  ### Android
  
  * Android源码中的策略模式实现（动画中的时间插值器）



- **模板方法模式**

  ### Intent

  定义算法框架，并将一些步骤的实现延迟到子类。

  通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。

  ### Class Diagram

  ![img](https://camo.githubusercontent.com/f17ac0490e8a98fcf30f0df9d19fb8ecb9b95b5af4e66e2d1d1ced0ce468b12f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61633661373934622d363863302d343836632d393032662d3864393838656565353736362e706e67)

  

  ### Implementation

  冲咖啡和冲茶都有类似的流程，但是某些步骤会有点不一样，要求复用那些相同步骤的代码。

  ![img](https://camo.githubusercontent.com/9fd715b86d1fd22399a35e9e26c9be7423bc453d270f95624c5d17eadbfd230d/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f31313233363439382d313431372d343663652d613162302d6531303035343235363935352e706e67)

  

  ```java
  public abstract class CaffeineBeverage {
  
      final void prepareRecipe() {
          boilWater();
          brew();
          pourInCup();
          addCondiments();
      }
  
      abstract void brew();
  
      abstract void addCondiments();
  
      void boilWater() {
          System.out.println("boilWater");
      }
  
      void pourInCup() {
          System.out.println("pourInCup");
      }
  }
  public class Coffee extends CaffeineBeverage {
      @Override
      void brew() {
          System.out.println("Coffee.brew");
      }
  
      @Override
      void addCondiments() {
          System.out.println("Coffee.addCondiments");
      }
  }
  public class Tea extends CaffeineBeverage {
      @Override
      void brew() {
          System.out.println("Tea.brew");
      }
  
      @Override
      void addCondiments() {
          System.out.println("Tea.addCondiments");
      }
  }
  public class Client {
      public static void main(String[] args) {
          CaffeineBeverage caffeineBeverage = new Coffee();
          caffeineBeverage.prepareRecipe();
          System.out.println("-----------");
          caffeineBeverage = new Tea();
          caffeineBeverage.prepareRecipe();
      }
  }
  ```

  ```java
  boilWater
  Coffee.brew
  pourInCup
  Coffee.addCondiments
  -----------
  boilWater
  Tea.brew
  pourInCup
  Tea.addCondiments
  ```

  ### Android

  * Android源码中的模板方法模式（AsyncTask）

  

  

- **访问者模式**

  ### Intent

  为一个对象结构（比如组合结构）增加新能力。

  ### Class Diagram

  - Visitor：访问者，为每一个 ConcreteElement 声明一个 visit 操作
  - ConcreteVisitor：具体访问者，存储遍历过程中的累计结果
  - ObjectStructure：对象结构，可以是组合结构，或者是一个集合。

  ![img](https://camo.githubusercontent.com/65512968e7624c4d6e1cf07d3251cf86a4018b112a9eb9c90c21f7602b17e050/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f37396336663033362d626465362d343339332d383561332d6566333661303332376264322e706e67)

  

  ### Implementation

  ```java
  public interface Element {
      void accept(Visitor visitor);
  }
  class CustomerGroup {
  
      private List<Customer> customers = new ArrayList<>();
  
      void accept(Visitor visitor) {
          for (Customer customer : customers) {
              customer.accept(visitor);
          }
      }
  
      void addCustomer(Customer customer) {
          customers.add(customer);
      }
  }
  public class Customer implements Element {
  
      private String name;
      private List<Order> orders = new ArrayList<>();
  
      Customer(String name) {
          this.name = name;
      }
  
      String getName() {
          return name;
      }
  
      void addOrder(Order order) {
          orders.add(order);
      }
  
      public void accept(Visitor visitor) {
          visitor.visit(this);
          for (Order order : orders) {
              order.accept(visitor);
          }
      }
  }
  public class Order implements Element {
  
      private String name;
      private List<Item> items = new ArrayList();
  
      Order(String name) {
          this.name = name;
      }
  
      Order(String name, String itemName) {
          this.name = name;
          this.addItem(new Item(itemName));
      }
  
      String getName() {
          return name;
      }
  
      void addItem(Item item) {
          items.add(item);
      }
  
      public void accept(Visitor visitor) {
          visitor.visit(this);
  
          for (Item item : items) {
              item.accept(visitor);
          }
      }
  }
  public class Item implements Element {
  
      private String name;
  
      Item(String name) {
          this.name = name;
      }
  
      String getName() {
          return name;
      }
  
      public void accept(Visitor visitor) {
          visitor.visit(this);
      }
  }
  public interface Visitor {
      void visit(Customer customer);
  
      void visit(Order order);
  
      void visit(Item item);
  }
  public class GeneralReport implements Visitor {
  
      private int customersNo;
      private int ordersNo;
      private int itemsNo;
  
      public void visit(Customer customer) {
          System.out.println(customer.getName());
          customersNo++;
      }
  
      public void visit(Order order) {
          System.out.println(order.getName());
          ordersNo++;
      }
  
      public void visit(Item item) {
          System.out.println(item.getName());
          itemsNo++;
      }
  
      public void displayResults() {
          System.out.println("Number of customers: " + customersNo);
          System.out.println("Number of orders:    " + ordersNo);
          System.out.println("Number of items:     " + itemsNo);
      }
  }
  public class Client {
      public static void main(String[] args) {
          Customer customer1 = new Customer("customer1");
          customer1.addOrder(new Order("order1", "item1"));
          customer1.addOrder(new Order("order2", "item1"));
          customer1.addOrder(new Order("order3", "item1"));
  
          Order order = new Order("order_a");
          order.addItem(new Item("item_a1"));
          order.addItem(new Item("item_a2"));
          order.addItem(new Item("item_a3"));
          Customer customer2 = new Customer("customer2");
          customer2.addOrder(order);
  
          CustomerGroup customers = new CustomerGroup();
          customers.addCustomer(customer1);
          customers.addCustomer(customer2);
  
          GeneralReport visitor = new GeneralReport();
          customers.accept(visitor);
          visitor.displayResults();
      }
  }
  ```

  ### Android

  

- [空对象.md](https://github.com/CyC2018/CS-Notes/blob/master/notes/设计模式 - 空对象.md)





## 参考资料



* [面向对象思想](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%80%9D%E6%83%B3.md)
* [设计模式目录](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%20-%20%E7%9B%AE%E5%BD%95.md)
* [Java 设计模式](https://juejin.cn/post/6844903695667167240)

